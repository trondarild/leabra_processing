/**
Implementation of a Leabra Unit, reproducing the behavior of emergent 8.0.

We implement only the rate-coded version. The code is intended to be as simple
as possible to understand. It is not in any way optimized for performance.
*/

// type of layer and correspondingly, unit behaviors
int INPUT  = 0;
int HIDDEN = 1;
int OUTPUT = 2;

class Unit{
    UnitSpec spec;

    Unit(){

    }
}

class UnitSpec{
    /**
    Units specification.

    Each unit can have different parameters values. They don't change during
    cycles, and unless you know what you're doing, you should not change them
    after the Unit creation. The best way to proceed is to create the UnitSpec,
    modify it, and provide the spec when instantiating a Unit:

    >>> spec = UnitSpec(act_thr=0.35) // specifying parameters at instantiation
    >>> spec.bias = 0.5               // you can also do it afterward
    >>> u = Unit(spec=spec)           // creating a Unit instance

    */

    // time step constants
    tau_net    = 1.4;     // net input integration time constant (net = g_e * g_bar_e)
    tau_v_m    = 3.3;     // v_m integration time constant
    // input channels parameters
    g_l        = 1.0;     // leak current (constant)
    g_bar_e    = 1.0;     // excitatory maximum conductance
    g_bar_l    = 0.1;     // leak maximum conductance
    g_bar_i    = 1.0;     // inhibitory maximum conductance
    // reversal potential
    e_rev_e    = 1.0 ;    // excitatory
    e_rev_l    = 0.3 ;    // leak
    e_rev_i    = 0.25;    // inhibitory
    // activation function parameters
    act_thr    = 0.5 ;    // threshold 2021-12-05 TAT: modulate via dopa D1 D2, adeno A1 A2
    c_act_thr = 0 // let original vary, this be constant; logistic(0) = 0.5
    act_gain   = 100 ;    // gain
    noisy_act  = True;    // If True, uses the noisy activation function
    act_sd     = 0.01;    // standard deviation of the noisy gaussian #FIXME: variance or sd?
    act_min    = 0.0 ;    // clamp ranges (min, max) for the activation value.
    act_max    = 0.95;    
    // spiking behavior
    spk_thr    = 1.2;     // spike threshold for resetting v_m // FIXME: actually used?
    v_m_init   = 0.4;     // init value for v_m
    v_m_r      = 0.3;     // reset value for v_m
    v_m_min    = 0.0;     // clamp ranges (min, max) for v_m
    v_m_max    = 2.0;     
    // adapt behavior
    adapt_on   = False  ; // if True, enable the adapt behavior
    dt_adapt   = 1/144. ; // time-step constant for adapt update
    v_m_gain   = 0.04   ; // gain on v_m driving the adaptation variable
    spike_gain = 0.00805; // value to add to the adaptation variable after spiking
    // bias #FIXME: not implemented.
    bias       = 0.0;
    // average parameters
    avg_init   = 0.15;
    avg_ss_dt  = 0.5;
    avg_s_dt   = 0.5;
    avg_m_dt   = 0.1;
    avg_l_dt   = 0.1 ;// computed once every trial #FIXME tau
    avg_l_init = 0.4;
    avg_l_min  = 0.2;
    avg_l_gain = 2.5;
    avg_m_in_s = 0.1;
    avg_lrn_min = 0.0001; // minimum avg_l_lrn value.
    avg_lrn_max = 0.5;    // maximum avg_l_lrn value
    // dopa and adenosine
    r_d1 = 0.0;
    r_d2 = 0.0;
    r_a1 = 0.0;
    r_a2 = 0.0;

    float[][] nxx1_conv;

    UnitSpec(){
        // TODO add params 
    }

    float avg_l_lrn(Unit unit){
        if (unit.genre != HIDDEN)  // no self-organization for non-hidden layers
            return 0.0
        avg_fact = (this.avg_lrn_max - this.avg_lrn_min)/(this.avg_l_gain - this.avg_l_min);
        return this.avg_lrn_min + avg_fact * (unit.avg_l - this.avg_l_min);
    }

}
